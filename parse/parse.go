package parse

import (
	"errors"
	"fmt"
	"lspctl/print"
	"maps"
	"slices"
	"strings"

	"gopkg.in/yaml.v3"
)

func formatParsed(p *ParsedYaml) {
    p.Desc = strings.ReplaceAll(p.Desc, "\n", " ") // make the entire description a single line
    p.Desc = strings.TrimSpace(p.Desc) // prevent leading and trailing spaces

    if p.Source.ExtraPkgs == nil {
        // transform a nil list (auto-generated by Unmarshal if there are no extra packages) into an empty one
        p.Source.ExtraPkgs = []string{}
    }
}

func parsePurl(id string) (parsedPurl, error) {
    const prefix = "pkg:"

    if !strings.HasPrefix(id, prefix) {
        return parsedPurl{}, fmt.Errorf("not a pkg PURL: '%s'", id)
    }

    rest := strings.TrimPrefix(id, prefix)
    parts := strings.SplitN(rest, "/", 2)
    if len(parts) != 2 {
        return parsedPurl{}, fmt.Errorf("Invalid PURL: '%s'", id)
    }

    source := parts[0]
    nameVersion := parts[1]

    name := nameVersion
    version := ""

    if at := strings.LastIndex(nameVersion, "@"); at != -1 {
        name = nameVersion[:at]
        version = nameVersion[at+1:]
    }

    return parsedPurl{
        RawSource: source,
        Name: name,
        Version: version,
    }, nil
}

func parseSource(purl parsedPurl, extraPkgs []string) (Source, error) {
    normal, err := normalizeSource(purl.RawSource)
    if err != nil {
        return Source{}, err
    }

    return Source{
        PkgSource: normal,
        Name: purl.Name,
        Version: purl.Version,
        ExtraPkgs: extraPkgs,
    }, nil
}

// ---

func ParseYaml(file string) (ParsedYaml, error) {
 	var parsed ParsedYaml
	if err := yaml.Unmarshal([]byte(file), &parsed); err != nil {
	    return ParsedYaml{}, err
	}

    formatParsed(&parsed)
    return parsed, nil
}

func ConvertInstall(parsed ParsedYaml) (InstallYaml, error) {
    if len(parsed.Bin) == 0 {
        return InstallYaml{}, errors.New("empty 'bin' field")
    }

    names := slices.Collect(maps.Keys(parsed.Bin))
    slices.Sort(names)

    bins := make([]Bin, 0, len(names))
    for _, name := range names {
        bins = append(bins, Bin{
            Name:   name,
            Target: parsed.Bin[name],
        })
    }
      
    purl, err := parsePurl(parsed.Source.Id)
    if err != nil {
        return InstallYaml{}, err
    }
    
    source, err := parseSource(purl, parsed.Source.ExtraPkgs)
    if err != nil {
        return InstallYaml{}, err
    }
    
    return InstallYaml{
        Name: parsed.Name,
        Source: source,
        Bins: bins,
    }, nil
}

// ---

func normalizeSource(raw string) (PackageSource, error) {
    switch raw {
        case "golang": return SourceGo, nil
        case "npm": return SourceNpm, nil
        case "github": return SourceGitHub, nil
        case "generic": return SourceGeneric, nil
        case "pypi": return SourcePypi, nil
        default: return SourceUnknown, fmt.Errorf("Unsupported source: '%s'", raw)
    }
}

func (src PackageSource) String() string {
    switch src {
        case SourceGo: return "golang"
        case SourceNpm: return "npm"
        case SourceGitHub: return "github"
        case SourceGeneric: return "generic"
        case SourcePypi: return "pypi"

        default:
            print.Failf("Unknown source: '%#v'", src)
            return "unknown" // shouldn't reach here.
    }
}
